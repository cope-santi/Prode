<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Eliminatorias An√≥nimas</title>
    <meta name="title" content="Eliminatorias An√≥nimas" />
    <meta name="description" content="F√∫tbol, f√∫tbol & f√∫tbol!" />

    <meta property="og:type" content="website" />
    <meta property="og:url" content="" />
    <meta property="og:title" content="Eliminatorias An√≥nimas" />
    <meta property="og:description" content="F√∫tbol, f√∫tbol & f√∫tbol!" />
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700;900&family=Montserrat:wght@400;500;600;700&family=Poppins:wght@400;500;600;700&family=Sacramento&display=swap" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="css/styles.css">
    <link rel="icon" href="./css/icon/favicon-ball.ico" />

    <script src="https://kit.fontawesome.com/e32607c50a.js" crossorigin="anonymous"></script>

</head>


<body>
    <nav class="navbar sticky-top navbar-expand-sm navbar-dark bg-dark ">
        <div class="container d-flex flex-column flex-md-row justify-content-between">
            <a class="navbar-brand" href="#">EA</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsExample03" aria-controls="navbarsExample03" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarsExample03">
                <ul class="navbar-nav me-auto mb-2 mb-sm-0">
                    <li class="nav-item">
                        <a class="nav-link" href="leaderboard.html">Leaderboard</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="game_weeks.html">Fases</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="fixtures.html">Fixtures</a>
                    </li>
                    <li class="nav-item" id="adminNavLink" style="display: none;">
                        <a class="nav-link" href="admin.html">Admin Panel</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#auth-ui">Iniciar sesi√≥n</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>


    <section class="hero-image-section py-2">
        <div class="hero-image-container">
            <img src="css/images/bg-cancha.jpg" class="img-fluid bg-img" alt="background-image">
        </div>
    </section>


    <section id="profile" class="py-2">
        <div class="colored-container m-md-3">

            <div class="d-md-flex flex-md-equal w-100 mt-md-0 mb-md-3 ps-md-3">

                <div class="me-md-0 pt-3 px-3 pt-md-0 px-md-5 text-center overflow-hidden w-100">
                    <div class="my-3 py-3">
                        <img class="img-profile" src="css/images/EA-logo.png" alt="profile">
                        <h1 class="fw-bold">Eliminatorias An√≥nimas</h1>
                        <p>-- Mundial 2026 --</p>
                        <div id="sync-status-banner" class="text-muted" style="font-size: 0.85rem;"></div>
                    </div>
                </div>

                <div class="me-md-0 pt-3 px-3 pt-md-0 px-md-5 text-center align-self-center overflow-hidden w-100">
                    <div class="my-3 py-3">
                        <h2 class="fw-bold">Muchachos...</h2>
                        <p class="profile-description">Si van a opinar, que sea falt√°ndose al respeto.</p>
                    </div>
                </div>

            </div>

        </div>
    </section>


    <section id="game-prediction-section" class="py-5"> <div class="container"> <div class="app-card prediction-section"> <h2>Submit Your Predictions</h2>
        <div id="auth-ui" class="mb-4">
            <div id="login-register-form">
                <div class="form-group mb-3">
                    <label for="userEmail">Email:</label>
                    <input type="email" id="userEmail" class="form-control" placeholder="Enter your email" required>
                </div>
                <div class="form-group mb-3">
                    <label for="userPassword">Password:</label>
                    <input type="password" id="userPassword" class="form-control" placeholder="Enter your password" required>
                    <div class="text-right mt-1">
                        <a href="#" id="forgotPasswordLink" class="text-muted small">Forgot Password?</a>
                    </div>
                </div>
                <button id="signInButton" class="btn btn-success me-2">Sign In</button>
                <button id="signUpButton" class="btn btn-info">Sign Up</button>
                <p id="auth-message" class="text-danger mt-3" style="font-weight: bold;"></p>
            </div>

            <div id="user-status-display" style="display: none;">
                <p>Welcome, <span id="userNameDisplay" style="font-weight: bold;"></span>!</p>
                <p>You are signed in as: <span id="userEmailDisplay" style="font-weight: bold;"></span></p>
                <button id="signOutButton" class="btn btn-danger mt-2">Sign Out</button>
            </div>
        </div>
                <div class="form-group">
                    <label for="playerName">Your Name:</label>
                    <input type="text" id="playerName" placeholder="Enter your name" required>
                </div>

                <div id="prediction-form-games" class="game-list">
                    Loading games for prediction...
                </div>

                <button id="submitPredictions" class="btn btn-primary-custom" disabled>Submit All Predictions</button>
                <p id="message" style="color: green; font-weight: bold; margin-top: 15px;"></p>
            </div>

            <hr class="my-5"> 
            
            <div id="my-predictions-section" class="prediction-section" style="display: none;"> <h2 class="section-heading">My World Cup 2026 Predictions</h2>
                <!-- Phase Selector for My Predictions -->
                <div id="my-predictions-phase-selector" class="gameweek-selector text-center mb-4" style="display: none;">
                    <h5 class="mb-3">Filter by Phase:</h5>
                    <div id="my-predictions-phase-buttons"></div>
                </div>
                <div id="my-predictions-list" class="game-list">
                    <p class="text-center">No predictions submitted yet.</p>
                </div>
            </div>
        </div> </section> 

        </div>

    </section>

    <section id=description class="py-2">

        <div class="bg-light p-3 p-md-5 mt-md-3 mb-md-0 text-center">
            <div class="col-md-5 mx-auto my-4">
                <h2 class='section-heading'>Paso a Paso ‚öΩ</h2>
            </div>
        </div>

        <div class="d-md-flex flex-md-equal w-100 mt-md-0 mb-md-3 ps-md-3">

            <div class="bg-light me-md-0 pt-3 px-3 pt-md-0 px-md-5 text-center text-black overflow-hidden w-100">
                <div class="my-3 py-3">
                    <img class="img-icon" src="css/images/pelota-de-futbol.svg" alt="data-analytics-icon">
                    <h3 class='skill-title'>Paso 1</h3>
                    <p class="description-step"> No money, no code (menos Daguish)
                </div>
            </div>

            <div class="bg-light me-md-0 pt-3 px-3 pt-md-0 px-md-5 text-center text-black overflow-hidden w-100">
                <div class="my-3 py-3">
                    <img class="img-icon" src="css/images/pelota-de-futbol.svg" alt="data-analytics-icon">
                    <h3 class='skill-title'>Paso 2</h3>
                    <p class="description-step"> Sube tus predicciones de marcadores
                </div>
            </div>

            <div class="bg-light me-md-0 pt-3 px-3 pt-md-0 px-md-5 text-center text-black overflow-hidden w-100">
                <div class="my-3 py-3">
                    <img class="img-icon" src="css/images/pelota-de-futbol.svg" alt="data-analytics-icon">
                    <h3 class='skill-title'>Paso 3</h3>
                    <p class="description-step"> Acosa al ADMIN para que mande tabla
                </div>
            </div>

        </div>
    </section>

    <section class="py-2">
        <div class="m-md-3 p-5 portfolio-section">
            <h2 class='section-heading'>Eliminatorias An√≥nimas</h2>
            <p>Vik, manda taaaaablaaaaa! üó£Ô∏è</p>
            <a class="btn btn-primary-custom" href="leaderboard.html">Leaderboard</a>
        </div>
    </section>

    <div class="footer-container">
        <a href="https://chat.whatsapp.com/2cUguIQ8AWhCTkfYLaixfi" target="_blank"><i class="footer-icon fab fa-whatsapp fa-2x"></i></a>
        <p class='footer-link'>¬© 2025 Jos√© Daniel Cu√©llar Lobo.</p>
    </div>

    <div class="modal fade" id="resetModal" tabindex="-1" role="dialog" aria-labelledby="resetModalLabel" aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content bg-dark text-white"> <div class="modal-header">
                    <h5 class="modal-title text-white" id="resetModalLabel">Password Reset</h5>
                    <button type="button" class="close text-white" id="closeHeaderButton" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body" id="resetModalBody">
                    </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="closeFooterButton">Close</button>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        // Import the functions you need from the SDKs you want to use
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getFirestore, collection, getDocs, getDoc, setDoc, deleteDoc, query, orderBy, limit, where, doc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
        // Import Authentication functions
        import { getAuth, signInWithPopup, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, sendPasswordResetEmail, signOut } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
        // Import centralized Firebase configuration
        import { firebaseConfig } from "./js/firebase-config.js";
        import { TOURNAMENT_CONFIG, resolveStageKey, resolveStageLabel, sortStageKeys } from "./js/tournament-config.js";
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app); // Get a reference to the Firestore database
        const auth = getAuth(app); // Get a reference to the Firebase Auth service // ADD THIS LINE

        loadSyncStatus();
        // New References for My Predictions section
        const myPredictionsSection = document.getElementById('my-predictions-section');
        const myPredictionsList = document.getElementById('my-predictions-list');

        let gamesForPrediction = []; // To store games that are upcoming for prediction
        let currentUserId = null; // To store the authenticated user's ID
        let currentUserEmail = null; // To store the authenticated user's email
        let allTeams = [];
        let stageUnlocks = {};

        const STAGE_ORDER = ['GROUP', 'R32', 'R16', 'QF', 'SF', '3P', 'FINAL'];
        const STAGE_PREREQ = {
            R32: 'GROUP',
            R16: 'R32',
            QF: 'R16',
            SF: 'QF',
            '3P': 'SF',
            FINAL: 'SF'
        };

        function getStageIdFromGame(game) {
            const stageKey = resolveStageKey(game);
            if (stageKey) {
                return stageKey.startsWith('GROUP-') ? 'GROUP' : stageKey;
            }
            return game.Stage || game.stage || null;
        }

        function buildStageState(games) {
            const state = {};
            STAGE_ORDER.forEach(stage => {
                state[stage] = { hasGames: false, allFinished: true };
            });

            games.forEach(game => {
                const stageId = getStageIdFromGame(game);
                if (!stageId || !state[stageId]) return;
                state[stageId].hasGames = true;
                const status = (game.Status || game.status || '').toLowerCase();
                if (status !== 'finished') {
                    state[stageId].allFinished = false;
                }
            });

            STAGE_ORDER.forEach(stage => {
                if (!state[stage].hasGames) {
                    state[stage].allFinished = false;
                }
            });

            return state;
        }

        function buildStageUnlocks(stageState) {
            return {
                GROUP: true,
                R32: stageState.GROUP.allFinished,
                R16: stageState.R32.allFinished,
                QF: stageState.R16.allFinished,
                SF: stageState.QF.allFinished,
                '3P': stageState.SF.allFinished,
                FINAL: stageState.SF.allFinished
            };
        }

        function getLockMessage(stageId) {
            const prereq = STAGE_PREREQ[stageId];
            if (!prereq) return 'Locked until previous phase is finished.';
            const label = resolveStageLabel({ StageKey: prereq });
            return `Locked until ${label} is finished.`;
        }

        // --- UI Element References ---
        const playerNameInput = document.getElementById('playerName');
        const submitPredictionsButton = document.getElementById('submitPredictions');
        const predictionMessageDiv = document.getElementById('message');

        const userEmailInput = document.getElementById('userEmail');
        const userPasswordInput = document.getElementById('userPassword');
        const signInButton = document.getElementById('signInButton');
        const signUpButton = document.getElementById('signUpButton');
        const authMessageDiv = document.getElementById('auth-message');
        const signOutButton = document.getElementById('signOutButton');
        const forgotPasswordLink = document.getElementById('forgotPasswordLink'); 
        const resetModalBody = document.getElementById('resetModalBody');
        const resetModalElement = document.getElementById('resetModal'); 
        
        const resetModal = new bootstrap.Modal(resetModalElement); 
        const closeHeaderButton = document.getElementById('closeHeaderButton');
        const closeFooterButton = document.getElementById('closeFooterButton');

        const loginRegisterFormDiv = document.getElementById('login-register-form');
        const userStatusDisplayDiv = document.getElementById('user-status-display');
        const userNameDisplay = document.getElementById('userNameDisplay');
        const userEmailDisplay = document.getElementById('userEmailDisplay');
        const adminNavLink = document.getElementById('adminNavLink');

        // --- Admin Configuration ---
        const ADMIN_UID = 'eP44roQf40ZOgh0rZYnsh91y7vI3'; // <--- REPLACE THIS WITH YOUR ACTUAL UID!

        // --- Functions to toggle UI state ---
        function setPredictionFormEnabled(enabled) {
            playerNameInput.disabled = !enabled;
            submitPredictionsButton.disabled = !enabled;
            // Also disable/enable prediction score inputs
            document.querySelectorAll('#prediction-form-games input[type="number"]').forEach(input => {
                const locked = input.dataset.locked === 'true';
                input.disabled = !enabled || locked;
            });
        }

        function displayAuthMessage(message, isError = false) {
            authMessageDiv.textContent = message;
            authMessageDiv.style.color = isError ? 'red' : 'green';
        }

        // --- Authentication State Listener ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                // User is signed in
                currentUserId = user.uid;
                currentUserEmail = user.email;

                // Update UI for signed-in state
                loginRegisterFormDiv.style.display = 'none'; // Hide login/register form
                userStatusDisplayDiv.style.display = 'block'; // Show user status
                userNameDisplay.textContent = user.email; // Default to email for display name
                userEmailDisplay.textContent = user.email;
                signOutButton.style.display = 'inline-block';

                // Enable prediction form and pre-fill player name
                setPredictionFormEnabled(true);
                playerNameInput.value = user.email.split('@')[0]; // Pre-fill with part of email
                predictionMessageDiv.textContent = ''; // Clear previous messages
                authMessageDiv.textContent = ''; // Clear auth message

                //console.log("User signed in:", user.email, "UID:", user.uid);

                // Show My Predictions section and load predictions
                myPredictionsSection.style.display = 'block';
                loadMyPredictions(); // Call the new function to load predictions for this user

                //console.log("User signed in:", user.email, "UID:", user.uid);

                // Show Admin Panel link if the user is the admin
                if (currentUserId === ADMIN_UID) {
                    adminNavLink.style.display = 'block';
                } else {
                    adminNavLink.style.display = 'none';
                }

                console.log("User signed in:", user.email, "UID:", user.uid);

            } else {
                // User is signed out
                currentUserId = null;
                currentUserEmail = null;

                // Update UI for signed-out state
                loginRegisterFormDiv.style.display = 'block'; // Show login/register form
                userStatusDisplayDiv.style.display = 'none'; // Hide user status
                signOutButton.style.display = 'none';

                // Disable prediction form
                setPredictionFormEnabled(false);
                playerNameInput.value = ''; // Clear player name
                predictionMessageDiv.textContent = 'Please sign in to submit predictions.';
                predictionMessageDiv.style.color = 'orange';
                authMessageDiv.textContent = ''; // Clear auth message

                //console.log("User signed out.");

                // Hide My Predictions section and clear its content
                myPredictionsSection.style.display = 'none';
                myPredictionsList.innerHTML = '<p class="text-center">No predictions submitted yet.</p>'; // Clear display

                // Hide Admin Panel link when signed out
                adminNavLink.style.display = 'none';

                console.log("User signed out.");
            }
        });

        // --- Auth Action Handlers ---
        signUpButton.addEventListener('click', async () => {
            const email = userEmailInput.value;
            const password = userPasswordInput.value;

            if (!email || !password) {
                displayAuthMessage("Please enter both email and password.", true);
                return;
            }
            if (password.length < 6) {
                displayAuthMessage("Password should be at least 6 characters.", true);
                return;
            }

            displayAuthMessage("Signing up...", false);
            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                console.log("User signed up and signed in:", userCredential.user.email);
                displayAuthMessage("Account created successfully! You are now signed in.", false);
                // No need to manually update UI here, onAuthStateChanged handles it
            } catch (error) {
                console.error("Error signing up:", error.message);
                displayAuthMessage(`Error signing up: ${error.message}`, true);
            }
        });

        signInButton.addEventListener('click', async () => {
            const email = userEmailInput.value;
            const password = userPasswordInput.value;

            if (!email || !password) {
                displayAuthMessage("Please enter both email and password.", true);
                return;
            }

            displayAuthMessage("Signing in...", false);
            try {
                const userCredential = await signInWithEmailAndPassword(auth, email, password);
                console.log("User signed in:", userCredential.user.email);
                displayAuthMessage("Signed in successfully!", false);
                // No need to manually update UI here, onAuthStateChanged handles it
            } catch (error) {
                console.error("Error signing in:", error.message);
                displayAuthMessage(`Error signing in: ${error.message}`, true);
            }
        });

        signOutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
                displayAuthMessage("Signed out successfully.", false);
                // No need to manually update UI here, onAuthStateChanged handles it
            } catch (error) {
                console.error("Error signing out:", error.message);
                displayAuthMessage(`Error signing out: ${error.message}`, true);
            }
        });

        // --- Game Loading and Prediction Submission (Modified) ---
        async function loadGames() {
            const predictionFormGamesDiv = document.getElementById('prediction-form-games');

            predictionFormGamesDiv.innerHTML = 'Loading games for prediction...';

            try {
                // Create a quick lookup map for team logos from the globally populated 'allTeams'
                const teamLogoMap = new Map();
                allTeams.forEach(team => {
                    if (team.name && team.logoUrl) {
                        teamLogoMap.set(team.name, team.logoUrl);
                    }
                });

                const gamesRef = collection(db, 'games');
                const q = query(
                    gamesRef,
                    where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                );
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    predictionFormGamesDiv.innerHTML = '<p>No games available for prediction.</p>';
                    setPredictionFormEnabled(false);
                    return;
                }

                predictionFormGamesDiv.innerHTML = '';
                gamesForPrediction = [];
                const allGames = [];

                snapshot.forEach(doc => {
                    const game = doc.data();
                    const gameId = doc.id;
                    allGames.push({ id: gameId, ...game });
                });

                const stageState = buildStageState(allGames);
                stageUnlocks = buildStageUnlocks(stageState);

                allGames.forEach(game => {
                    const gameId = game.id;
                    const stageLabel = resolveStageLabel(game);
                    const stageId = getStageIdFromGame(game);
                    const isLocked = stageId && stageUnlocks.hasOwnProperty(stageId) ? !stageUnlocks[stageId] : false;
                    const lockMessage = isLocked ? getLockMessage(stageId) : '';

                    const homeTeamLogo = teamLogoMap.get(game.HomeTeam) || 'path/to/default_logo.png';
                    const awayTeamLogo = teamLogoMap.get(game.AwayTeam) || 'path/to/default_logo.png';

                    // Populate prediction form for upcoming games only
                    if (game.Status && game.Status.toLowerCase() === 'upcoming') {
                        const predictionGameCard = document.createElement('div');
                        predictionGameCard.classList.add('app-card', 'prediction-game-card');
                        if (isLocked) {
                            predictionGameCard.style.opacity = '0.7';
                        }

                        const disabledAttr = isLocked ? 'disabled data-locked="true"' : '';
                        const lockNotice = isLocked ? `<p class="text-warning" style="margin-top: 8px; font-size: 0.9rem;">${lockMessage}</p>` : '';

                        predictionGameCard.innerHTML = `
                            <div class="teams-row">
                                <div class="team">
                                    <img src="${homeTeamLogo}" alt="${game.HomeTeam} Logo" class="team-logo-small">
                                    <span class="team-name">${game.HomeTeam}</span>
                                </div>
                                <div class="vs-separator">vs</div>
                                <div class="team">
                                    <img src="${awayTeamLogo}" alt="${game.AwayTeam} Logo" class="team-logo-small">
                                    <span class="team-name">${game.AwayTeam}</span>
                                </div>    
                            </div>
                            <p class="game-detail-line"><strong>Phase:</strong> ${stageLabel}</p>       
                            <div class="prediction-inputs">
                                <input type="number" data-game-id="${gameId}" data-team="home" placeholder="H" min="0" class="score-input" ${disabledAttr}>
                                <span class="score-separator">-</span>
                                <input type="number" data-game-id="${gameId}" data-team="away" placeholder="A" min="0" class="score-input" ${disabledAttr}>
                            </div>                     
                            ${lockNotice}
                        `;
                        predictionFormGamesDiv.appendChild(predictionGameCard);
                        gamesForPrediction.push({ id: gameId, ...game, isLocked });
                    }
                });
                gamesForPrediction.sort((a, b) => {
                    const timeA = a.KickOffTime ? new Date(a.KickOffTime).getTime() : 0;
                    const timeB = b.KickOffTime ? new Date(b.KickOffTime).getTime() : 0;
                    return timeA - timeB;
                });

                if (gamesForPrediction.length === 0) {
                    setPredictionFormEnabled(false);
                    predictionFormGamesDiv.innerHTML = '<p>No upcoming games to predict.</p>';
                } else {
                    const hasUnlockedGames = gamesForPrediction.some(game => !game.isLocked);
                    setPredictionFormEnabled(!!currentUserId && hasUnlockedGames);
                }

            } catch (error) {
                console.error("Error fetching games: ", error);
                predictionFormGamesDiv.innerHTML = '<p>Error loading games for prediction.</p>';
                setPredictionFormEnabled(false);
            }
        }



        async function submitPredictions() {
            if (!currentUserId) {
                predictionMessageDiv.textContent = 'You must be signed in to submit predictions!';
                predictionMessageDiv.style.color = 'red';
                return;
            }

            const playerName = playerNameInput.value.trim();
            if (!playerName) {
                predictionMessageDiv.textContent = 'Please enter your name for the prediction!';
                predictionMessageDiv.style.color = 'red';
                return;
            }

            setPredictionFormEnabled(false); // Disable button and inputs to prevent double submission
            predictionMessageDiv.textContent = '<p class="loading-message">Submitting predictions...</p>';
            predictionMessageDiv.style.color = 'orange';

            const predictionInputs = document.querySelectorAll('#prediction-form-games input[type="number"]');
            const predictions = {};

            predictionInputs.forEach(input => {
                const gameId = input.dataset.gameId;
                const team = input.dataset.team;
                const score = parseInt(input.value, 10);

                if (!predictions[gameId]) {
                    predictions[gameId] = { gameId: gameId };
                }
                if (team === 'home') {
                    predictions[gameId].predictedHomeScore = isNaN(score) ? null : score;
                } else {
                    predictions[gameId].predictedAwayScore = isNaN(score) ? null : score;
                }
            });

            let successCount = 0;
            let errorOccurred = false;

            for (const gameId in predictions) {
                if (predictions.hasOwnProperty(gameId)) {
                    const prediction = predictions[gameId];

                    const gameInfo = gamesForPrediction.find(g => g.id === gameId);
                    if (!gameInfo) {
                        console.warn(`Skipping prediction for game ${gameId}: game info not found.`);
                        continue;
                    }
                    if (gameInfo.isLocked) {
                        console.warn(`Skipping prediction for game ${gameId}: phase is locked.`);
                        continue;
                    }
                    if (gameInfo.Status && gameInfo.Status.toLowerCase() !== 'upcoming') {
                        console.warn(`Skipping prediction for game ${gameId} (status is ${gameInfo.Status}).`);
                        continue;
                    }
                    if (gameInfo.KickOffTime) {
                        const kickOffValue = gameInfo.KickOffTime.toDate ? gameInfo.KickOffTime.toDate() : gameInfo.KickOffTime;
                        const kickOffMillis = new Date(kickOffValue).getTime();
                        if (!Number.isNaN(kickOffMillis) && kickOffMillis <= Date.now()) {
                            console.warn(`Skipping prediction for game ${gameId}: kickoff already passed.`);
                            continue;
                        }
                    }

                    if (prediction.predictedHomeScore === null || prediction.predictedAwayScore === null) {
                        console.warn(`Skipping prediction for game ${gameId} by ${playerName}: Incomplete scores.`);
                        continue;
                    }

                    try {
                        const predictionsRef = collection(db, 'predictions');
                        const existingPredictionsQuery = query(
                            predictionsRef,
                            where('userId', '==', currentUserId),
                            where('gameId', '==', gameId),
                            where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                        );
                        const existingPredictionsSnapshot = await getDocs(existingPredictionsQuery);

                        const predictionData = {
                            userId: currentUserId,
                            playerName: playerName,
                            gameId: gameId,
                            predictedHomeScore: prediction.predictedHomeScore,
                            predictedAwayScore: prediction.predictedAwayScore,
                            tournamentId: TOURNAMENT_CONFIG.tournamentId,
                            timestamp: new Date() // Update timestamp on every submission
                        };

                        const predictionDocId = `${currentUserId}_${gameId}`;
                        const predictionDocRef = doc(db, 'predictions', predictionDocId);

                        // Upsert canonical document for this (user, game)
                        await setDoc(predictionDocRef, predictionData, { merge: true });
                        console.log(`Upserted prediction for game ${gameId} by ${playerName} (Doc ID: ${predictionDocId})`);

                        // Clean up any stray duplicates that may exist
                        const deletePromises = [];
                        existingPredictionsSnapshot.forEach(existingDoc => {
                            if (existingDoc.id !== predictionDocId) {
                                deletePromises.push(deleteDoc(existingDoc.ref));
                            }
                        });
                        if (deletePromises.length > 0) {
                            await Promise.all(deletePromises);
                            console.log(`Removed ${deletePromises.length} duplicate prediction document(s) for game ${gameId}.`);
                        }

                        successCount++;
                    } catch (error) {
                        console.error("Error submitting prediction for game", gameId, ": ", error);
                        errorOccurred = true;
                    }
                }
            }

            if (successCount > 0 && !errorOccurred) {
                predictionMessageDiv.textContent = `Successfully submitted ${successCount} prediction(s)!`;
                predictionMessageDiv.style.color = 'green';
                // Clear prediction input fields, keep player name
                predictionInputs.forEach(input => input.value = '');
                // ADD THIS LINE BELOW to refresh "My Predictions"
                loadMyPredictions(); // Refresh "My Predictions" after submission!
            } else if (successCount > 0 && errorOccurred) {
                predictionMessageDiv.textContent = `Submitted ${successCount} prediction(s) with some errors. Check console.`;
                predictionMessageDiv.style.color = 'orange';
            } else {
                predictionMessageDiv.textContent = 'No valid predictions submitted.';
                predictionMessageDiv.style.color = 'red';
            }
            // Ensure this is outside the if/else if/else block
            setPredictionFormEnabled(true);
        }

        // --- New Function: Load and Display My Predictions ---
        // Global variables for My Predictions filtering
        let allUserPredictions = [];
        let gamesMapForPredictions = new Map();
        let selectedMyPredictionsPhase = null;
        const myPredictionsPhaseSelector = document.getElementById('my-predictions-phase-selector');

        async function loadMyPredictions() {
            if (!currentUserId) {
                myPredictionsList.innerHTML = '<p class="text-center">Please sign in to see your predictions.</p>';
                return;
            }

            myPredictionsList.innerHTML = '<p class="text-center">Loading your predictions...</p>';

            try {
                const myPredictionsRef = collection(db, 'predictions');
                const q = query(
                    myPredictionsRef,
                    where('userId', '==', currentUserId),
                    where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                );
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    myPredictionsList.innerHTML = '<p class="text-center">You have not submitted any predictions yet.</p>';
                    myPredictionsPhaseSelector.style.display = 'none';
                    return;
                }

                // Store all user's predictions
                allUserPredictions = [];
                snapshot.forEach(predictionDoc => {
                    allUserPredictions.push(predictionDoc.data());
                });
                allUserPredictions.sort((a, b) => {
                    const timeA = a.timestamp ? new Date(a.timestamp.toDate ? a.timestamp.toDate() : a.timestamp).getTime() : 0;
                    const timeB = b.timestamp ? new Date(b.timestamp.toDate ? b.timestamp.toDate() : b.timestamp).getTime() : 0;
                    return timeB - timeA;
                });

                // Fetch all game data once
                gamesMapForPredictions = new Map();
                const gamesSnapshot = await getDocs(query(
                    collection(db, 'games'),
                    where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                ));
                gamesSnapshot.forEach(doc => {
                    gamesMapForPredictions.set(doc.id, doc.data());
                });

                // Extract unique phases from user's predictions
                const phaseSet = new Set();
                allUserPredictions.forEach(pred => {
                    const game = gamesMapForPredictions.get(pred.gameId);
                    const stageKey = game ? resolveStageKey(game) : null;
                    if (stageKey) {
                        phaseSet.add(stageKey);
                    }
                });

                const phaseList = sortStageKeys(Array.from(phaseSet));

                // Show phase selector only if there are multiple phases
                if (phaseList.length > 1) {
                    myPredictionsPhaseSelector.style.display = 'block';
                    // Select the latest phase by default
                    selectedMyPredictionsPhase = phaseList[phaseList.length - 1];
                    
                    // Import the helper functions
                    const { createPhaseSelector, updatePhaseSelectorState } = await import('./js/ui-helpers.js');
                    
                    createPhaseSelector(
                        phaseList,
                        (phaseKey) => {
                            selectedMyPredictionsPhase = phaseKey;
                            updatePhaseSelectorState('my-predictions-phase-buttons', phaseKey);
                            displayFilteredMyPredictions();
                        },
                        'my-predictions-phase-buttons',
                        phaseList[phaseList.length - 1],
                        'myPredictionsPhaseSelector',
                        (phaseKey) => resolveStageLabel({ StageKey: phaseKey })
                    );
                } else if (phaseList.length === 1) {
                    myPredictionsPhaseSelector.style.display = 'none';
                    selectedMyPredictionsPhase = phaseList[0];
                }

                displayFilteredMyPredictions();

            } catch (error) {
                console.error("Error loading user predictions: ", error);
                myPredictionsList.innerHTML = '<p class="text-center" style="color: red;">Error loading your predictions. Please try again later.</p>';
            }
        }

        // Display filtered My Predictions based on selected phase
        function displayFilteredMyPredictions() {
            const filteredPredictions = selectedMyPredictionsPhase
                ? allUserPredictions.filter(pred => {
                    const game = gamesMapForPredictions.get(pred.gameId);
                    return game && resolveStageKey(game) === selectedMyPredictionsPhase;
                })
                : allUserPredictions;

            if (filteredPredictions.length === 0) {
                myPredictionsList.innerHTML = '<p class="text-center">No predictions for this phase.</p>';
                return;
            }

            myPredictionsList.innerHTML = '';

            filteredPredictions.forEach(prediction => {
                const gameId = prediction.gameId;
                const game = gamesMapForPredictions.get(gameId);

                if (game) {
                    const predictionCard = document.createElement('div');
                    predictionCard.classList.add('app-card','game-card');

                    let predictionTime = 'N/A';
                    if (prediction.timestamp) {
                        const rawTimestamp = prediction.timestamp.toDate ? prediction.timestamp.toDate() : prediction.timestamp;
                        const parsedTimestamp = new Date(rawTimestamp);
                        if (!Number.isNaN(parsedTimestamp.getTime())) {
                            predictionTime = parsedTimestamp.toLocaleString();
                        }
                    }

                    const phaseLabel = resolveStageLabel(game);

                    predictionCard.innerHTML = `
                        <h3>${game.HomeTeam} vs ${game.AwayTeam}</h3>
                        <p><strong>Phase:</strong> ${phaseLabel}</p>
                        <p><strong>Your Prediction:</strong> ${prediction.predictedHomeScore} - ${prediction.predictedAwayScore}</p>
                        <p><strong>Game Status:</strong> <span class="status ${game.Status ? game.Status.toLowerCase() : ''}">${game.Status || 'N/A'}</span></p>
                        ${game.Status && game.Status.toLowerCase() === 'finished' ? `<p><strong>Actual Result:</strong> ${game.HomeScore !== null && game.HomeScore !== undefined ? game.HomeScore : '?'} - ${game.AwayScore !== null && game.AwayScore !== undefined ? game.AwayScore : '?'}</p>` : ''}
                        <p><small>Submitted: ${predictionTime}</small></p>
                    `;
                    myPredictionsList.appendChild(predictionCard);
                }
            });
        }

        async function loadSyncStatus() {
            const banner = document.getElementById('sync-status-banner');
            if (!banner) return;

            try {
                const statusRef = doc(db, 'sync_status', TOURNAMENT_CONFIG.tournamentId);
                const statusSnap = await getDoc(statusRef);
                const data = statusSnap.exists() ? statusSnap.data() : {};
                const lastSync = data.lastSuccessAt || data.lastSyncedAt || data.lastRunAt;
                const lastText = lastSync
                    ? (lastSync.toDate ? lastSync.toDate().toLocaleString() : new Date(lastSync).toLocaleString())
                    : 'N/A';
                banner.textContent = `Actualizaci√≥n autom√°tica post-partido (no en vivo). √öltima sync: ${lastText}`;
            } catch (error) {
                banner.textContent = 'Actualizaci√≥n autom√°tica post-partido (no en vivo).';
            }
        }

        // --- Main Application Initialization Function ---
        async function initializeAppContent() {
            try {
                // First, fetch teams for logo display
                console.log("Initializing app content: Fetching teams for logos...");
                const teamsRef = collection(db, 'teams');
                const teamsSnapshot = await getDocs(query(teamsRef, orderBy('name')));
                allTeams = [];
                teamsSnapshot.forEach(doc => {
                    allTeams.push({ id: doc.id, ...doc.data() });
                });
                console.log("Teams loaded:", allTeams.length, "teams");

                // Then load and display games
                console.log("Initializing app content: Loading games...");
                await loadGames();
                console.log("App content initialization complete.");

            } catch (error) {
                console.error("Error during app content initialization:", error);
            }
        }

        forgotPasswordLink.addEventListener('click', async (e) => {
            e.preventDefault();

            // 1. Get the email address from the email input field
            const email = userEmailInput.value.trim();
            
            // Check if email is empty
            if (!email) {
                resetModalBody.innerHTML = 'Please enter your email address in the field above before clicking "Forgot Password."';
                resetModal.show(); // <-- Use the NATIVE JS modal instance
                return;
            }

            // Clear previous message
            resetModalBody.innerHTML = 'Sending password reset link...';
            resetModal.show(); // <-- Use the NATIVE JS modal instance to show loading state

            try {
                // 2. Send the password reset email using Firebase Auth
                await sendPasswordResetEmail(auth, email);

                // 3. Success Feedback
                resetModalBody.innerHTML = `
                    <p>Password reset email successfully sent to <strong>${email}</strong>.</p>
                    <p>Please check your inbox (and spam folder) for instructions on resetting your password.</p>
                `;

            } catch (error) {
                let errorMessage = "An error occurred while sending the reset email. Please try again.";
                
                // Handle common Firebase errors
                if (error.code === 'auth/user-not-found') {
                    errorMessage = "No user found with that email address.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "The email address is not valid.";
                } else {
                    console.error("Password reset error:", error);
                    // Fallback for unexpected errors
                    errorMessage = `Error: ${error.message || error.code}.`;
                }
                
                // 4. Error Feedback
                resetModalBody.innerHTML = `<p class="text-danger">${errorMessage}</p>`;
                
                // The modal is already shown, so we just update the content.
            }
        });

        closeHeaderButton.addEventListener('click', () => {
            // resetModal is the native JS instance initialized earlier: const resetModal = new bootstrap.Modal(resetModalElement);
            resetModal.hide();
        });

        closeFooterButton.addEventListener('click', () => {
            resetModal.hide();
        });

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            // Submit predictions button listener
            const submitPredictionsButton = document.getElementById('submitPredictions'); // Ensure this element is defined globally
            if (submitPredictionsButton) {
                submitPredictionsButton.addEventListener('click', submitPredictions);
            } else {
                console.warn("submitPredictionsButton not found. Check HTML ID.");
            }

            // ===========================================================
            // CRUCIAL CHANGE: Start the main app initialization here!
            // ===========================================================
            initializeAppContent();
        });

    </script>

</body>
</html>

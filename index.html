<!DOCTYPE html>
<html lang="es" dir="ltr">

<head>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Prode Mundial 2026</title>
    <meta name="title" content="Prode Mundial 2026" />
    <meta name="description" content="Prode del Mundial 2026 con predicciones, tabla y fixtures actualizados." />

    <meta property="og:type" content="website" />
    <meta property="og:url" content="" />
    <meta property="og:title" content="Prode Mundial 2026" />
    <meta property="og:description" content="Prode del Mundial 2026 con predicciones, tabla y fixtures actualizados." />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="icon" href="./css/icon/favicon-ball.ico" />

    <script src="https://kit.fontawesome.com/e32607c50a.js" crossorigin="anonymous"></script>

</head>


<body>
    <header id="app-navbar"></header>


    <header class="hero">
        <div class="hero-bg" aria-hidden="true">
            <img src="css/images/bg3.jpg" alt="">
        </div>
        <div class="hero-overlay" aria-hidden="true"></div>
        <div class="hero-pattern" aria-hidden="true"></div>
        <div class="container hero-inner">
            <div class="hero-content">
                <div class="hero-brand">
                    <div class="hero-emblem" aria-hidden="true">
                        <span class="hero-emblem-text">WC</span>
                        <span class="hero-emblem-year">26</span>
                    </div>
                    <div class="hero-brand-text">
                        <span class="hero-badge">MUNDIAL 2026</span>
                        <span class="hero-tagline">USA / Mexico / Canada</span>
                    </div>
                </div>
                <h1>Prode Mundial 2026</h1>
                <p class="hero-subtitle">Predici resultados, suma puntos y vivi cada fase del Mundial.</p>
                <div class="hero-actions">
                    <a class="btn btn-primary-custom" href="#game-prediction-section">Empezar</a>
                    <a class="btn btn-secondary-custom" href="leaderboard.html">Ver tabla</a>
                    <a class="btn btn-ghost" href="fixtures.html">Ver partidos</a>
                </div>
                <div class="hero-ribbon">
                    <span>Fase de grupos</span>
                    <span>R32</span>
                    <span>R16</span>
                    <span>Cuartos</span>
                    <span>Semis</span>
                    <span>Final</span>
                </div>
                <div id="sync-status-banner" class="sync-status-banner"></div>
            </div>
            <div class="hero-panel">
                <h2 class="hero-panel-title">Vivi el Mundial 2026</h2>
                <p>Arma tu prode, segui la tabla y senti cada partido como final.</p>
                <div class="hero-stats">
                    <div class="hero-stat">
                        <span class="stat-value">48</span>
                        <span class="stat-label">Selecciones</span>
                    </div>
                    <div class="hero-stat">
                        <span class="stat-value">104</span>
                        <span class="stat-label">Partidos</span>
                    </div>
                    <div class="hero-stat">
                        <span class="stat-value">3</span>
                        <span class="stat-label">Sedes</span>
                    </div>
                </div>
                <div class="hero-panel-note">Sedes 2026: USA, Mexico y Canada.</div>
            </div>
        </div>
    </header>

    <section id="game-prediction-section" class="py-5">
        <div class="container">
            <div class="app-card prediction-section">
                <h2>Carga tus predicciones</h2>
                <p class="section-lede">Tres pasos y listo: inicia sesión, completa marcadores y envía.</p>
                <div class="quick-steps">
                    <div class="quick-step">
                        <span class="quick-step-number">1</span>
                        <div class="quick-step-text">
                            <span class="quick-step-title">Inicia sesión</span>
                            <span class="quick-step-note">Con tu correo</span>
                        </div>
                    </div>
                    <div class="quick-step">
                        <span class="quick-step-number">2</span>
                        <div class="quick-step-text">
                            <span class="quick-step-title">Completa marcadores</span>
                            <span class="quick-step-note">Partido por partido</span>
                        </div>
                    </div>
                    <div class="quick-step">
                        <span class="quick-step-number">3</span>
                        <div class="quick-step-text">
                            <span class="quick-step-title">Envía todo</span>
                            <span class="quick-step-note">Guarda tus predicciones</span>
                        </div>
                    </div>
                </div>
                <div id="auth-ui" class="mb-4">
                    <div id="login-register-form">
                        <div class="form-group mb-3">
                            <label for="userEmail">Correo:</label>
                            <input type="email" id="userEmail" class="form-control" placeholder="Ingresa tu correo" required>
                        </div>
                        <div class="form-group mb-3">
                            <label for="userPassword">Contraseña:</label>
                            <input type="password" id="userPassword" class="form-control" placeholder="Ingresa tu contraseña" required>
                            <div class="text-right mt-1">
                                <a href="#" id="forgotPasswordLink" class="text-muted small">¿Olvidaste tu contraseña?</a>
                            </div>
                        </div>
                        <button id="signInButton" class="btn btn-success me-2">Entrar</button>
                        <button id="signUpButton" class="btn btn-info">Crear cuenta</button>
                        <p id="auth-message" class="text-danger mt-3" style="font-weight: bold;"></p>
                    </div>

                    <div id="user-status-display" style="display: none;">
                        <p>Bienvenido, <span id="userNameDisplay" style="font-weight: bold;"></span>!</p>
                        <p>Sesión iniciada con: <span id="userEmailDisplay" style="font-weight: bold;"></span></p>
                        <button id="signOutButton" class="btn btn-danger mt-2">Salir</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="playerName">Tu nombre:</label>
                    <input type="text" id="playerName" placeholder="Ingresa tu nombre" required>
                </div>

                <div id="prediction-form-games" class="game-list">
                    Cargando partidos...
                </div>

                <button id="submitPredictions" class="btn btn-primary-custom" disabled>Enviar predicciones</button>
                <p id="message" class="status-message"></p>
            </div>

            <hr class="my-5">

            <div id="my-predictions-section" class="app-card prediction-section" style="display: none;">
                <h2 class="section-heading">Mis predicciones del Mundial 2026</h2>
                <div id="my-predictions-filters" class="filter-bar" style="display: none;">
                    <div class="filter-bar__row">
                        <div class="filter-stack">
                            <div class="filter-field">
                                <label for="my-stage-filter">Etapa</label>
                                <select id="my-stage-filter">
                                    <option value="ALL">Todas</option>
                                    <option value="GROUP">Grupos</option>
                                    <option value="R32">Ronda de 32</option>
                                    <option value="R16">Octavos</option>
                                    <option value="QF">Cuartos</option>
                                    <option value="SF">Semis</option>
                                    <option value="3P">Tercer puesto</option>
                                    <option value="FINAL">Final</option>
                                </select>
                            </div>
                            <div class="filter-field" id="my-group-filter-field" style="display: none;">
                                <label for="my-group-filter">Grupo</label>
                                <select id="my-group-filter">
                                    <option value="ALL">Todos</option>
                                    <option value="A">Grupo A</option>
                                    <option value="B">Grupo B</option>
                                    <option value="C">Grupo C</option>
                                    <option value="D">Grupo D</option>
                                    <option value="E">Grupo E</option>
                                    <option value="F">Grupo F</option>
                                    <option value="G">Grupo G</option>
                                    <option value="H">Grupo H</option>
                                </select>
                            </div>
                        </div>
                        <div class="filter-field">
                            <label for="my-status-filter">Estado</label>
                            <select id="my-status-filter">
                                <option value="ALL">Todos</option>
                                <option value="finished">Finalizados</option>
                                <option value="live">En vivo</option>
                                <option value="upcoming">Proximos</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div id="my-predictions-list" class="game-list">
                    <p class="text-center">Todavía no hay predicciones.</p>
                </div>
            </div>
        </div>
    </section>


    <div class="modal fade" id="resetModal" tabindex="-1" role="dialog" aria-labelledby="resetModalLabel" aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content bg-dark text-white"> <div class="modal-header">
                    <h5 class="modal-title text-white" id="resetModalLabel">Restablecer contraseña</h5>
                    <button type="button" class="close text-white" id="closeHeaderButton" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body" id="resetModalBody">
                    </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="closeFooterButton">Cerrar</button>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        import { mountNavbar } from "./js/layout.js";
        // Import the functions you need from the SDKs you want to use
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getFirestore, collection, getDocs, getDoc, setDoc, deleteDoc, query, orderBy, limit, where, doc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
        // Import Authentication functions
        import { getAuth, signInWithPopup, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, sendPasswordResetEmail, signOut } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
        // Import centralized Firebase configuration
        import { firebaseConfig } from "./js/firebase-config.js";
        import { TOURNAMENT_CONFIG, resolveStageKey, resolveStageLabel } from "./js/tournament-config.js";
        
        mountNavbar({ activeKey: "home" });

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app); // Get a reference to the Firestore database
        const auth = getAuth(app); // Get a reference to the Firebase Auth service // ADD THIS LINE

        loadSyncStatus();
        // New References for My Predictions section
        const myPredictionsSection = document.getElementById('my-predictions-section');
        const myPredictionsList = document.getElementById('my-predictions-list');
        const myPredictionsFilterBar = document.getElementById('my-predictions-filters');
        const myPredictionsStageSelect = document.getElementById('my-stage-filter');
        const myPredictionsGroupField = document.getElementById('my-group-filter-field');
        const myPredictionsGroupSelect = document.getElementById('my-group-filter');
        const myPredictionsStatusSelect = document.getElementById('my-status-filter');

        let gamesForPrediction = []; // To store games that are upcoming for prediction
        let currentUserId = null; // To store the authenticated user's ID
        let currentUserEmail = null; // To store the authenticated user's email
        let allTeams = [];
        let teamLogoMap = new Map();
        let stageUnlocks = {};
        let userPredictionsByGame = new Map();

        const STAGE_ORDER = ['GROUP', 'R32', 'R16', 'QF', 'SF', '3P', 'FINAL'];
        const STAGE_PREREQ = {
            R32: 'GROUP',
            R16: 'R32',
            QF: 'R16',
            SF: 'QF',
            '3P': 'SF',
            FINAL: 'SF'
        };

        function getStageIdFromGame(game) {
            const stageKey = resolveStageKey(game);
            if (stageKey) {
                return stageKey.startsWith('GROUP-') ? 'GROUP' : stageKey;
            }
            return game.Stage || game.stage || null;
        }

        function buildStageState(games) {
            const state = {};
            STAGE_ORDER.forEach(stage => {
                state[stage] = { hasGames: false, allFinished: true };
            });

            games.forEach(game => {
                const stageId = getStageIdFromGame(game);
                if (!stageId || !state[stageId]) return;
                state[stageId].hasGames = true;
                const status = (game.Status || game.status || '').toLowerCase();
                if (status !== 'finished') {
                    state[stageId].allFinished = false;
                }
            });

            STAGE_ORDER.forEach(stage => {
                if (!state[stage].hasGames) {
                    state[stage].allFinished = false;
                }
            });

            return state;
        }

        function buildStageUnlocks(stageState) {
            return {
                GROUP: true,
                R32: stageState.GROUP.allFinished,
                R16: stageState.R32.allFinished,
                QF: stageState.R16.allFinished,
                SF: stageState.QF.allFinished,
                '3P': stageState.SF.allFinished,
                FINAL: stageState.SF.allFinished
            };
        }

        function getLockMessage(stageId) {
            const prereq = STAGE_PREREQ[stageId];
            if (!prereq) return 'Bloqueado hasta que finalice la fase anterior.';
            const label = resolveStageLabel({ StageKey: prereq });
            return `Bloqueado hasta que finalice ${label}.`;
        }

        // --- UI Element References ---
        const playerNameInput = document.getElementById('playerName');
        const submitPredictionsButton = document.getElementById('submitPredictions');
        const predictionMessageDiv = document.getElementById('message');

        const userEmailInput = document.getElementById('userEmail');
        const userPasswordInput = document.getElementById('userPassword');
        const signInButton = document.getElementById('signInButton');
        const signUpButton = document.getElementById('signUpButton');
        const authMessageDiv = document.getElementById('auth-message');
        const signOutButton = document.getElementById('signOutButton');
        const forgotPasswordLink = document.getElementById('forgotPasswordLink'); 
        const resetModalBody = document.getElementById('resetModalBody');
        const resetModalElement = document.getElementById('resetModal'); 
        
        const resetModal = new bootstrap.Modal(resetModalElement); 
        const closeHeaderButton = document.getElementById('closeHeaderButton');
        const closeFooterButton = document.getElementById('closeFooterButton');

        const loginRegisterFormDiv = document.getElementById('login-register-form');
        const userStatusDisplayDiv = document.getElementById('user-status-display');
        const userNameDisplay = document.getElementById('userNameDisplay');
        const userEmailDisplay = document.getElementById('userEmailDisplay');
        const adminNavLink = document.getElementById('adminNavLink');

        // --- Admin Configuration ---
        const ADMIN_UID = 'eP44roQf40ZOgh0rZYnsh91y7vI3'; // <--- REPLACE THIS WITH YOUR ACTUAL UID!

        // --- Functions to toggle UI state ---
        function setPredictionFormEnabled(enabled) {
            playerNameInput.disabled = !enabled;
            submitPredictionsButton.disabled = !enabled;
            // Also disable/enable prediction score inputs
            document.querySelectorAll('#prediction-form-games input[type="number"]').forEach(input => {
                const locked = input.dataset.locked === 'true';
                const started = input.dataset.started === 'true';
                input.disabled = !enabled || locked || started;
            });
        }

        function displayAuthMessage(message, isError = false) {
            authMessageDiv.textContent = message;
            authMessageDiv.style.color = isError ? 'red' : 'green';
        }

        function setPredictionMessage(message, type = 'info') {
            predictionMessageDiv.textContent = message;
            predictionMessageDiv.classList.remove('loading-message', 'error-message', 'info-message', 'success-message');
            const typeClassMap = {
                loading: 'loading-message',
                error: 'error-message',
                info: 'info-message',
                success: 'success-message'
            };
            if (typeClassMap[type]) {
                predictionMessageDiv.classList.add(typeClassMap[type]);
            }
        }

        // --- Authentication State Listener ---
        function updateNavbarForUser(user) {
            const isAdmin = user && user.uid === ADMIN_UID;
            mountNavbar({
                activeKey: 'home',
                showAdmin: isAdmin
            });
        }

        onAuthStateChanged(auth, (user) => {
            updateNavbarForUser(user);
            if (user) {
                // User is signed in
                currentUserId = user.uid;
                currentUserEmail = user.email;

                // Update UI for signed-in state
                loginRegisterFormDiv.style.display = 'none'; // Hide login/register form
                userStatusDisplayDiv.style.display = 'block'; // Show user status
                userNameDisplay.textContent = user.email; // Default to email for display name
                userEmailDisplay.textContent = user.email;
                signOutButton.style.display = 'inline-block';

                // Enable prediction form and pre-fill player name
                setPredictionFormEnabled(true);
                playerNameInput.value = user.email.split('@')[0]; // Pre-fill with part of email
                setPredictionMessage('');
                authMessageDiv.textContent = ''; // Clear auth message

                //console.log("User signed in:", user.email, "UID:", user.uid);

                // Show My Predictions section and load predictions
                myPredictionsSection.style.display = 'block';
                loadMyPredictions(); // Call the new function to load predictions for this user
                loadUserPredictionsForForm();

                //console.log("User signed in:", user.email, "UID:", user.uid);

                if (adminNavLink) {
                    adminNavLink.style.display = currentUserId === ADMIN_UID ? 'block' : 'none';
                }

                console.log("User signed in:", user.email, "UID:", user.uid);

            } else {
                // User is signed out
                currentUserId = null;
                currentUserEmail = null;

                // Update UI for signed-out state
                loginRegisterFormDiv.style.display = 'block'; // Show login/register form
                userStatusDisplayDiv.style.display = 'none'; // Hide user status
                signOutButton.style.display = 'none';

                // Disable prediction form
                setPredictionFormEnabled(false);
                playerNameInput.value = ''; // Clear player name
                setPredictionMessage('Inicia sesión para enviar predicciones.', 'info');
                authMessageDiv.textContent = ''; // Clear auth message

                //console.log("User signed out.");

                // Hide My Predictions section and clear its content
                myPredictionsSection.style.display = 'none';
                myPredictionsList.innerHTML = '<p class="text-center">Todavía no hay predicciones.</p>'; // Clear display
                if (myPredictionsFilterBar) {
                    myPredictionsFilterBar.style.display = 'none';
                }
                userPredictionsByGame = new Map();
                loadGames();

                if (adminNavLink) {
                    adminNavLink.style.display = 'none';
                }

                console.log("User signed out.");
            }
        });

        // --- Auth Action Handlers ---
        signUpButton.addEventListener('click', async () => {
            const email = userEmailInput.value;
            const password = userPasswordInput.value;

            if (!email || !password) {
                displayAuthMessage("Ingresa correo y contraseña.", true);
                return;
            }
            if (password.length < 6) {
                displayAuthMessage("La contraseña debe tener al menos 6 caracteres.", true);
                return;
            }

            displayAuthMessage("Creando cuenta...", false);
            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                console.log("User signed up and signed in:", userCredential.user.email);
                displayAuthMessage("Cuenta creada. Sesión iniciada.", false);
                // No need to manually update UI here, onAuthStateChanged handles it
            } catch (error) {
                console.error("Error signing up:", error.message);
                displayAuthMessage(`Error al crear cuenta: ${error.message}`, true);
            }
        });

        signInButton.addEventListener('click', async () => {
            const email = userEmailInput.value;
            const password = userPasswordInput.value;

            if (!email || !password) {
                displayAuthMessage("Ingresa correo y contraseña.", true);
                return;
            }

            displayAuthMessage("Iniciando sesión...", false);
            try {
                const userCredential = await signInWithEmailAndPassword(auth, email, password);
                console.log("User signed in:", userCredential.user.email);
                displayAuthMessage("Sesión iniciada.", false);
                // No need to manually update UI here, onAuthStateChanged handles it
            } catch (error) {
                console.error("Error signing in:", error.message);
                displayAuthMessage(`Error al iniciar sesión: ${error.message}`, true);
            }
        });

        signOutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
                displayAuthMessage("Sesión cerrada.", false);
                // No need to manually update UI here, onAuthStateChanged handles it
            } catch (error) {
                console.error("Error signing out:", error.message);
                displayAuthMessage(`Error al cerrar sesión: ${error.message}`, true);
            }
        });

        // --- Game Loading and Prediction Submission (Modified) ---
        async function loadGames() {
            const predictionFormGamesDiv = document.getElementById('prediction-form-games');

            predictionFormGamesDiv.innerHTML = 'Cargando partidos...';

            try {
                const gamesRef = collection(db, 'games');
                const q = query(
                    gamesRef,
                    where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                );
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    predictionFormGamesDiv.innerHTML = '<p>No hay partidos para pronosticar.</p>';
                    setPredictionFormEnabled(false);
                    return;
                }

                predictionFormGamesDiv.innerHTML = '';
                gamesForPrediction = [];
                const allGames = [];

                snapshot.forEach(doc => {
                    const game = doc.data();
                    const gameId = doc.id;
                    allGames.push({ id: gameId, ...game });
                });

                const stageState = buildStageState(allGames);
                stageUnlocks = buildStageUnlocks(stageState);

                allGames.forEach(game => {
                    const gameId = game.id;
                    const stageLabel = resolveStageLabel(game);
                    const stageId = getStageIdFromGame(game);
                    const isLocked = stageId && stageUnlocks.hasOwnProperty(stageId) ? !stageUnlocks[stageId] : false;
                    const lockMessage = isLocked ? getLockMessage(stageId) : '';
                    const statusValue = (game.Status || game.status || '').toLowerCase();
                    const kickOffValue = game.KickOffTime?.toDate ? game.KickOffTime.toDate() : game.KickOffTime;
                    const kickOffMillis = kickOffValue ? new Date(kickOffValue).getTime() : NaN;
                    const hasStarted = statusValue !== 'upcoming' || (!Number.isNaN(kickOffMillis) && kickOffMillis <= Date.now());

                    const homeTeamLogo = teamLogoMap.get(game.HomeTeam) || 'path/to/default_logo.png';
                    const awayTeamLogo = teamLogoMap.get(game.AwayTeam) || 'path/to/default_logo.png';

                    // Populate prediction form for upcoming games only
                    if (game.Status && game.Status.toLowerCase() === 'upcoming') {
                        const predictionGameCard = document.createElement('div');
                        predictionGameCard.classList.add('app-card', 'prediction-game-card');
                        if (isLocked) {
                            predictionGameCard.style.opacity = '0.7';
                        }

                        const disabledAttr = `${isLocked ? 'disabled data-locked="true"' : ''} ${hasStarted ? 'disabled data-started="true"' : ''}`;
                        const lockNotice = isLocked
                            ? `<p class="lock-notice">${lockMessage}</p>`
                            : hasStarted
                                ? `<p class="lock-notice">Predicciones cerradas: el partido ya empezó.</p>`
                                : '';

                        predictionGameCard.innerHTML = `
                            <div class="teams-row">
                                <div class="team">
                                    <img src="${homeTeamLogo}" alt="${game.HomeTeam} Logo" class="team-logo-small">
                                    <span class="team-name">${game.HomeTeam}</span>
                                </div>
                                <div class="vs-separator">vs</div>
                                <div class="team">
                                    <img src="${awayTeamLogo}" alt="${game.AwayTeam} Logo" class="team-logo-small">
                                    <span class="team-name">${game.AwayTeam}</span>
                                </div>    
                            </div>
                            <p class="game-detail-line"><strong>Fase:</strong> ${stageLabel}</p>       
                            <div class="prediction-inputs">
                                <input type="number" data-game-id="${gameId}" data-team="home" placeholder="H" min="0" class="score-input" ${disabledAttr}>
                                <span class="score-separator">-</span>
                                <input type="number" data-game-id="${gameId}" data-team="away" placeholder="A" min="0" class="score-input" ${disabledAttr}>
                            </div>                     
                            ${lockNotice}
                        `;
                        predictionFormGamesDiv.appendChild(predictionGameCard);
                        gamesForPrediction.push({ id: gameId, ...game, isLocked });
                    }
                });
                gamesForPrediction.sort((a, b) => {
                    const timeA = a.KickOffTime ? new Date(a.KickOffTime).getTime() : 0;
                    const timeB = b.KickOffTime ? new Date(b.KickOffTime).getTime() : 0;
                    return timeA - timeB;
                });

                if (gamesForPrediction.length === 0) {
                    setPredictionFormEnabled(false);
                    predictionFormGamesDiv.innerHTML = '<p>No hay partidos próximos para predecir.</p>';
                } else {
                    const hasUnlockedGames = gamesForPrediction.some(game => !game.isLocked);
                    setPredictionFormEnabled(!!currentUserId && hasUnlockedGames);
                    applyUserPredictionsToForm();
                }

            } catch (error) {
                console.error("Error fetching games: ", error);
                predictionFormGamesDiv.innerHTML = '<p>Error al cargar partidos para predicción.</p>';
                setPredictionFormEnabled(false);
            }
        }

        async function loadUserPredictionsForForm() {
            if (!currentUserId) return;

            try {
                const predictionsRef = collection(db, 'predictions');
                const q = query(
                    predictionsRef,
                    where('userId', '==', currentUserId),
                    where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                );
                const snapshot = await getDocs(q);
                userPredictionsByGame = new Map();
                snapshot.forEach(doc => {
                    const prediction = doc.data();
                    if (prediction.gameId) {
                        userPredictionsByGame.set(prediction.gameId, prediction);
                    }
                });
                applyUserPredictionsToForm();
            } catch (error) {
                console.error("Error loading user predictions for form: ", error);
            }
        }

        function applyUserPredictionsToForm() {
            if (!userPredictionsByGame || userPredictionsByGame.size === 0) return;
            document.querySelectorAll('#prediction-form-games input[type="number"]').forEach(input => {
                const gameId = input.dataset.gameId;
                const prediction = userPredictionsByGame.get(gameId);
                if (!prediction) return;
                const value = input.dataset.team === 'home' ? prediction.predictedHomeScore : prediction.predictedAwayScore;
                if (value !== null && value !== undefined) {
                    input.value = value;
                }
            });
        }



        async function submitPredictions() {
            if (!currentUserId) {
                setPredictionMessage('Debes iniciar sesión para enviar predicciones.', 'error');
                return;
            }

            const playerName = playerNameInput.value.trim();
            if (!playerName) {
                setPredictionMessage('Ingresa tu nombre para guardar la predicción.', 'error');
                return;
            }

            setPredictionFormEnabled(false); // Disable button and inputs to prevent double submission
            setPredictionMessage('Enviando predicciones...', 'loading');

            const predictionInputs = document.querySelectorAll('#prediction-form-games input[type="number"]');
            const predictions = {};

            predictionInputs.forEach(input => {
                const gameId = input.dataset.gameId;
                const team = input.dataset.team;
                const score = parseInt(input.value, 10);

                if (!predictions[gameId]) {
                    predictions[gameId] = { gameId: gameId };
                }
                if (team === 'home') {
                    predictions[gameId].predictedHomeScore = isNaN(score) ? null : score;
                } else {
                    predictions[gameId].predictedAwayScore = isNaN(score) ? null : score;
                }
            });

            let successCount = 0;
            let errorOccurred = false;

            for (const gameId in predictions) {
                if (predictions.hasOwnProperty(gameId)) {
                    const prediction = predictions[gameId];

                    const gameInfo = gamesForPrediction.find(g => g.id === gameId);
                    if (!gameInfo) {
                        console.warn(`Skipping prediction for game ${gameId}: game info not found.`);
                        continue;
                    }
                    if (gameInfo.isLocked) {
                        console.warn(`Skipping prediction for game ${gameId}: phase is locked.`);
                        continue;
                    }
                    if (gameInfo.Status && gameInfo.Status.toLowerCase() !== 'upcoming') {
                        console.warn(`Skipping prediction for game ${gameId} (status is ${gameInfo.Status}).`);
                        continue;
                    }
                    if (gameInfo.KickOffTime) {
                        const kickOffValue = gameInfo.KickOffTime.toDate ? gameInfo.KickOffTime.toDate() : gameInfo.KickOffTime;
                        const kickOffMillis = new Date(kickOffValue).getTime();
                        if (!Number.isNaN(kickOffMillis) && kickOffMillis <= Date.now()) {
                            console.warn(`Skipping prediction for game ${gameId}: kickoff already passed.`);
                            continue;
                        }
                    }

                    if (prediction.predictedHomeScore === null || prediction.predictedAwayScore === null) {
                        console.warn(`Skipping prediction for game ${gameId} by ${playerName}: Incomplete scores.`);
                        continue;
                    }

                    try {
                        const predictionsRef = collection(db, 'predictions');
                        const existingPredictionsQuery = query(
                            predictionsRef,
                            where('userId', '==', currentUserId),
                            where('gameId', '==', gameId),
                            where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                        );
                        const existingPredictionsSnapshot = await getDocs(existingPredictionsQuery);

                        const predictionData = {
                            userId: currentUserId,
                            playerName: playerName,
                            userEmail: currentUserEmail || '',
                            gameId: gameId,
                            predictedHomeScore: prediction.predictedHomeScore,
                            predictedAwayScore: prediction.predictedAwayScore,
                            tournamentId: TOURNAMENT_CONFIG.tournamentId,
                            timestamp: new Date() // Update timestamp on every submission
                        };

                        const predictionDocId = `${currentUserId}_${gameId}`;
                        const predictionDocRef = doc(db, 'predictions', predictionDocId);

                        // Upsert canonical document for this (user, game)
                        await setDoc(predictionDocRef, predictionData, { merge: true });
                        console.log(`Upserted prediction for game ${gameId} by ${playerName} (Doc ID: ${predictionDocId})`);

                        // Clean up any stray duplicates that may exist
                        const deletePromises = [];
                        existingPredictionsSnapshot.forEach(existingDoc => {
                            if (existingDoc.id !== predictionDocId) {
                                deletePromises.push(deleteDoc(existingDoc.ref));
                            }
                        });
                        if (deletePromises.length > 0) {
                            await Promise.all(deletePromises);
                            console.log(`Removed ${deletePromises.length} duplicate prediction document(s) for game ${gameId}.`);
                        }

                        successCount++;
                    } catch (error) {
                        console.error("Error submitting prediction for game", gameId, ": ", error);
                        errorOccurred = true;
                    }
                }
            }

            if (successCount > 0 && !errorOccurred) {
                setPredictionMessage(`Se enviaron ${successCount} predicción(es) correctamente.`, 'success');
                // Clear prediction input fields, keep player name
                predictionInputs.forEach(input => input.value = '');
                // ADD THIS LINE BELOW to refresh "My Predictions"
                loadMyPredictions(); // Refresh "My Predictions" after submission!
            } else if (successCount > 0 && errorOccurred) {
                setPredictionMessage(`Se enviaron ${successCount} predicción(es) con algunos errores. Revisa la consola.`, 'info');
            } else {
                setPredictionMessage('No se enviaron predicciones válidas.', 'error');
            }
            // Ensure this is outside the if/else if/else block
            setPredictionFormEnabled(true);
        }

        // --- New Function: Load and Display My Predictions ---
        // Global variables for My Predictions filtering
        let allUserPredictions = [];
        let gamesMapForPredictions = new Map();
        let selectedMyPredictionsStage = 'ALL';
        let selectedMyPredictionsGroup = 'ALL';
        let selectedMyPredictionsStatus = 'ALL';
        let myPredictionsFiltersInitialized = false;

        function normalizeGameStatus(game) {
            const statusValue = (game.Status || game.status || 'upcoming').toLowerCase();
            return statusValue === 'in_play' ? 'live' : statusValue;
        }

        function resolvePredictionPhaseLabel(game) {
            const stageValue = String(game.Stage || game.stage || '').toUpperCase();
            const groupValue = String(game.Group || game.group || '').toUpperCase();
            if (stageValue === 'GROUP' && groupValue) {
                return `Grupo ${groupValue}`;
            }
            return resolveStageLabel(game);
        }

        function updateMyPredictionsGroupVisibility() {
            if (!myPredictionsGroupField || !myPredictionsGroupSelect) return;
            const showGroup = selectedMyPredictionsStage === 'GROUP';
            myPredictionsGroupField.style.display = showGroup ? 'flex' : 'none';
            if (!showGroup) {
                selectedMyPredictionsGroup = 'ALL';
                myPredictionsGroupSelect.value = 'ALL';
            }
        }

        function initializeMyPredictionsFilters() {
            if (myPredictionsFiltersInitialized) return;
            if (myPredictionsStageSelect) {
                myPredictionsStageSelect.addEventListener('change', () => {
                    selectedMyPredictionsStage = myPredictionsStageSelect.value;
                    updateMyPredictionsGroupVisibility();
                    displayFilteredMyPredictions();
                });
            }
            if (myPredictionsGroupSelect) {
                myPredictionsGroupSelect.addEventListener('change', () => {
                    selectedMyPredictionsGroup = myPredictionsGroupSelect.value;
                    displayFilteredMyPredictions();
                });
            }
            if (myPredictionsStatusSelect) {
                myPredictionsStatusSelect.addEventListener('change', () => {
                    selectedMyPredictionsStatus = myPredictionsStatusSelect.value;
                    displayFilteredMyPredictions();
                });
            }
            myPredictionsFiltersInitialized = true;
        }

        async function loadMyPredictions() {
            if (!currentUserId) {
                myPredictionsList.innerHTML = '<p class="text-center">Inicia sesión para ver tus predicciones.</p>';
                if (myPredictionsFilterBar) {
                    myPredictionsFilterBar.style.display = 'none';
                }
                return;
            }

            myPredictionsList.innerHTML = '<p class="text-center">Cargando tus predicciones...</p>';

            try {
                const myPredictionsRef = collection(db, 'predictions');
                const q = query(
                    myPredictionsRef,
                    where('userId', '==', currentUserId),
                    where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                );
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    myPredictionsList.innerHTML = '<p class="text-center">Todavía no cargaste predicciones.</p>';
                    if (myPredictionsFilterBar) {
                        myPredictionsFilterBar.style.display = 'none';
                    }
                    return;
                }

                // Store all user's predictions
                allUserPredictions = [];
                snapshot.forEach(predictionDoc => {
                    allUserPredictions.push(predictionDoc.data());
                });
                allUserPredictions.sort((a, b) => {
                    const timeA = a.timestamp ? new Date(a.timestamp.toDate ? a.timestamp.toDate() : a.timestamp).getTime() : 0;
                    const timeB = b.timestamp ? new Date(b.timestamp.toDate ? b.timestamp.toDate() : b.timestamp).getTime() : 0;
                    return timeB - timeA;
                });

                // Fetch all game data once
                gamesMapForPredictions = new Map();
                const gamesSnapshot = await getDocs(query(
                    collection(db, 'games'),
                    where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                ));
                gamesSnapshot.forEach(doc => {
                    gamesMapForPredictions.set(doc.id, doc.data());
                });

                if (myPredictionsFilterBar) {
                    myPredictionsFilterBar.style.display = 'block';
                }
                initializeMyPredictionsFilters();
                if (myPredictionsStageSelect) {
                    myPredictionsStageSelect.value = selectedMyPredictionsStage;
                }
                if (myPredictionsGroupSelect) {
                    myPredictionsGroupSelect.value = selectedMyPredictionsGroup;
                }
                if (myPredictionsStatusSelect) {
                    myPredictionsStatusSelect.value = selectedMyPredictionsStatus;
                }
                updateMyPredictionsGroupVisibility();

                displayFilteredMyPredictions();

            } catch (error) {
                console.error("Error loading user predictions: ", error);
                myPredictionsList.innerHTML = '<p class="text-center" style="color: red;">Error al cargar tus predicciones. Intenta nuevamente más tarde.</p>';
            }
        }

        // Display filtered My Predictions based on selected filters
        function displayFilteredMyPredictions() {
            const filteredPredictions = allUserPredictions.filter(pred => {
                const game = gamesMapForPredictions.get(pred.gameId);
                if (!game) return false;

                const stageId = getStageIdFromGame(game);
                if (selectedMyPredictionsStage !== 'ALL' && stageId !== selectedMyPredictionsStage) {
                    return false;
                }

                if (selectedMyPredictionsStage === 'GROUP' && selectedMyPredictionsGroup !== 'ALL') {
                    const groupValue = String(game.Group || game.group || '').toUpperCase();
                    if (groupValue !== selectedMyPredictionsGroup) {
                        return false;
                    }
                }

                if (selectedMyPredictionsStatus !== 'ALL') {
                    const normalizedStatus = normalizeGameStatus(game);
                    if (normalizedStatus !== selectedMyPredictionsStatus) {
                        return false;
                    }
                }

                return true;
            });

            if (filteredPredictions.length === 0) {
                myPredictionsList.innerHTML = '<p class="text-center">No hay predicciones para este filtro.</p>';
                return;
            }

            myPredictionsList.innerHTML = '';

            filteredPredictions.forEach(prediction => {
                const gameId = prediction.gameId;
                const game = gamesMapForPredictions.get(gameId);

                if (game) {
                    const predictionCard = document.createElement('div');
                    predictionCard.classList.add('app-card', 'game-card');

                    let predictionTime = 'N/A';
                    if (prediction.timestamp) {
                        const rawTimestamp = prediction.timestamp.toDate ? prediction.timestamp.toDate() : prediction.timestamp;
                        const parsedTimestamp = new Date(rawTimestamp);
                        if (!Number.isNaN(parsedTimestamp.getTime())) {
                            predictionTime = parsedTimestamp.toLocaleString();
                        }
                    }

                    const phaseLabel = resolvePredictionPhaseLabel(game);
                    const statusValue = normalizeGameStatus(game);
                    const statusLabelMap = {
                        finished: 'Finalizado',
                        live: 'En vivo',
                        upcoming: 'Proximo'
                    };
                    const statusClass = statusValue === 'live' ? 'live' : statusValue;
                    const statusLabel = statusLabelMap[statusValue] || statusValue;
                    const predictedHome = prediction.predictedHomeScore ?? '-';
                    const predictedAway = prediction.predictedAwayScore ?? '-';
                    const homeLogoUrl = teamLogoMap.get(game.HomeTeam) || '';
                    const awayLogoUrl = teamLogoMap.get(game.AwayTeam) || '';

                    predictionCard.innerHTML = `
                        <div class="teams-row">
                            <div class="team">
                                ${homeLogoUrl ? `<img src="${homeLogoUrl}" alt="${game.HomeTeam} Logo" class="team-logo">` : '<div class="team-logo-placeholder">-</div>'}
                                <p class="team-name">${game.HomeTeam}</p>
                            </div>
                            <div class="vs-separator">vs</div>
                            <div class="team">
                                ${awayLogoUrl ? `<img src="${awayLogoUrl}" alt="${game.AwayTeam} Logo" class="team-logo">` : '<div class="team-logo-placeholder">-</div>'}
                                <p class="team-name">${game.AwayTeam}</p>
                            </div>
                        </div>
                        <p><strong>Fase:</strong> ${phaseLabel}</p>
                        <p><strong>Estado:</strong> <span class="status ${statusClass}">${statusLabel}</span></p>
                        <p><strong>Tu predicción:</strong> ${predictedHome} - ${predictedAway}</p>
                        ${statusValue === 'finished' ? `<p><strong>Resultado real:</strong> ${game.HomeScore !== null && game.HomeScore !== undefined ? game.HomeScore : '?'} - ${game.AwayScore !== null && game.AwayScore !== undefined ? game.AwayScore : '?'}</p>` : ''}
                        <p><small>Enviado: ${predictionTime}</small></p>
                    `;
                    myPredictionsList.appendChild(predictionCard);
                }
            });
        }

        async function loadSyncStatus() {
            const banner = document.getElementById('sync-status-banner');
            if (!banner) return;

            try {
                const statusRef = doc(db, 'sync_status', TOURNAMENT_CONFIG.tournamentId);
                const statusSnap = await getDoc(statusRef);
                const data = statusSnap.exists() ? statusSnap.data() : {};
                const lastSync = data.lastSuccessAt || data.lastSyncedAt || data.lastRunAt;
                const lastText = lastSync
                    ? (lastSync.toDate ? lastSync.toDate().toLocaleString() : new Date(lastSync).toLocaleString())
                    : 'N/A';
                banner.textContent = `Actualización automática post-partido (no en vivo). Última sync: ${lastText}`;
            } catch (error) {
                banner.textContent = 'Actualización automática post-partido (no en vivo).';
            }
        }

        // --- Main Application Initialization Function ---
        async function initializeAppContent() {
            try {
                // First, fetch teams for logo display
                console.log("Initializing app content: Fetching teams for logos...");
                const teamsRef = collection(db, 'teams');
                const teamsSnapshot = await getDocs(query(teamsRef, orderBy('name')));
                allTeams = [];
                teamsSnapshot.forEach(doc => {
                    allTeams.push({ id: doc.id, ...doc.data() });
                });
                teamLogoMap = new Map();
                allTeams.forEach(team => {
                    if (team.name && team.logoUrl) {
                        teamLogoMap.set(team.name, team.logoUrl);
                    }
                });
                console.log("Teams loaded:", allTeams.length, "teams");

                // Then load and display games
                console.log("Initializing app content: Loading games...");
                await loadGames();
                console.log("App content initialization complete.");

            } catch (error) {
                console.error("Error during app content initialization:", error);
            }
        }

        forgotPasswordLink.addEventListener('click', async (e) => {
            e.preventDefault();

            // 1. Get the email address from the email input field
            const email = userEmailInput.value.trim();
            
            // Check if email is empty
            if (!email) {
                resetModalBody.innerHTML = 'Ingresa tu correo en el campo anterior antes de seleccionar "Olvidé mi contraseña".';
                resetModal.show(); // <-- Use the NATIVE JS modal instance
                return;
            }

            // Clear previous message
            resetModalBody.innerHTML = 'Enviando enlace de restablecimiento de contraseña...';
            resetModal.show(); // <-- Use the NATIVE JS modal instance to show loading state

            try {
                // 2. Send the password reset email using Firebase Auth
                await sendPasswordResetEmail(auth, email);

                // 3. Success Feedback
                resetModalBody.innerHTML = `
                    <p>Se envió el correo de restablecimiento a <strong>${email}</strong>.</p>
                    <p>Revisa tu bandeja de entrada (y la carpeta de spam) para seguir las instrucciones.</p>
                `;

            } catch (error) {
                let errorMessage = "Ocurrió un error al enviar el correo de restablecimiento. Intenta de nuevo.";
                
                // Handle common Firebase errors
                if (error.code === 'auth/user-not-found') {
                    errorMessage = "No encontramos un usuario con ese correo.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "El correo ingresado no es válido.";
                } else {
                    console.error("Password reset error:", error);
                    // Fallback for unexpected errors
                    errorMessage = `Error: ${error.message || error.code}.`;
                }
                
                // 4. Error Feedback
                resetModalBody.innerHTML = `<p class="text-danger">${errorMessage}</p>`;
                
                // The modal is already shown, so we just update the content.
            }
        });

        closeHeaderButton.addEventListener('click', () => {
            // resetModal is the native JS instance initialized earlier: const resetModal = new bootstrap.Modal(resetModalElement);
            resetModal.hide();
        });

        closeFooterButton.addEventListener('click', () => {
            resetModal.hide();
        });

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            // Submit predictions button listener
            const submitPredictionsButton = document.getElementById('submitPredictions'); // Ensure this element is defined globally
            if (submitPredictionsButton) {
                submitPredictionsButton.addEventListener('click', submitPredictions);
            } else {
                console.warn("submitPredictionsButton not found. Check HTML ID.");
            }

            // ===========================================================
            // CRUCIAL CHANGE: Start the main app initialization here!
            // ===========================================================
            initializeAppContent();
        });

    </script>

</body>
</html>

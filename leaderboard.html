<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabla - Mundial 2026</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/styles_final.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="icon" href="./css/icon/favicon-ball.ico" />
</head>
<body class="bg-dark text-white">

    <header id="app-navbar"></header>

    <div class="container py-4">
        <section class="section-hero">
            <div class="section-hero-content">
                <span class="hero-badge">MUNDIAL 2026</span>
                <h1 class="hero-title">Tabla general</h1>
                <p class="hero-subtitle">Segui el ranking completo y los resultados actualizados.</p>
            </div>
        </section>
        <div id="sync-status-banner" class="text-center text-muted" style="margin-bottom: 16px; font-size: 0.85rem;"></div>

        <div id="overall-leaderboard-container" class="game-results-card mb-5" style="display: none;">
            <h2 class="text-center mb-4">Tabla general de jugadores</h2>
            <div id="leaderboard-list">
                <p class="text-center text-muted">Calculando puntajes...</p>
            </div>
        </div>

        <div id="all-games-results-container">
            <p class="text-center text-muted">Cargando resultados y predicciones...</p>
        </div>
    </div>

    <!-- Player History Modal -->
    <div id="player-history-modal" class="player-history-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="player-history-title">Historial del jugador</h3>
                <span class="close-modal" style="cursor: pointer;" onclick="document.getElementById('player-history-modal').style.display = 'none';">&times;</span>
            </div>
            <div class="modal-body">
                <div id="player-history-content"></div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <script type="module">
        import { mountNavbar } from "./js/layout.js";
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where, doc, getDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
        import { calculatePoints, calculatePlayerStats } from "./js/calculations.js";
        import { firebaseConfig } from "./js/firebase-config.js";
        import { renderLeaderboardTable, createPlayerHistoryModal, openPlayerHistory, setupPlayerClickHandlers } from "./js/ui-helpers.js";
        import { TOURNAMENT_CONFIG, resolveStageLabel } from "./js/tournament-config.js";

        mountNavbar("leaderboard");

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // UI Elements
        const allGamesResultsContainer = document.getElementById('all-games-results-container');
        const overallLeaderboardContainer = document.getElementById('overall-leaderboard-container');
        const leaderboardList = document.getElementById('leaderboard-list');

        // Store user display names for modal
        let userDisplayNamesGlobal = {};
        const statusLabelMap = {
            finished: 'Finalizado',
            live: 'En vivo',
            in_play: 'En vivo',
            upcoming: 'Próximo'
        };
        const statusClassMap = {
            finished: 'finished',
            live: 'ongoing',
            in_play: 'ongoing',
            upcoming: 'upcoming'
        };

        // Create player history modal on page load
        createPlayerHistoryModal();

        // Setup global player click handler
        setupPlayerClickHandlers((userId) => {
            openPlayerHistory(userId, db, userDisplayNamesGlobal);
        });

        loadSyncStatus();

        // --- Load All Results Function ---
        async function loadAllResults() {
            allGamesResultsContainer.innerHTML = '<p class="text-center text-muted">Cargando resultados y predicciones...</p>';

            try {
                // 1. Fetch all games
                const gamesSnapshot = await getDocs(query(
                    collection(db, 'games'),
                    where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                ));
                const games = [];
                const gamesById = {};
                
                gamesSnapshot.forEach(doc => {
                    const gameData = { id: doc.id, ...doc.data() };
                    games.push(gameData);
                    gamesById[doc.id] = gameData;
                });

                // 2. Fetch all predictions
                const predictionsSnapshot = await getDocs(query(
                    collection(db, 'predictions'),
                    where('tournamentId', '==', TOURNAMENT_CONFIG.tournamentId)
                ));
                const predictions = [];
                
                predictionsSnapshot.forEach(doc => {
                    predictions.push(doc.data());
                });

                // 3. Use the centralized calculatePlayerStats function from calculations.js
                const playerStats = calculatePlayerStats(games, predictions);

                // 4. Build userNames map from predictions
                const userNames = {};
                predictions.forEach(pred => {
                    const userId = pred.userId || 'unknown';
                    const playerName = pred.playerName || 'Anónimo';
                    userNames[userId] = playerName;
                });

                // Store for global access in modals
                userDisplayNamesGlobal = userNames;

                // 5. Render the overall leaderboard using ui-helpers
                renderLeaderboardContainer(playerStats, userNames);

                // 6. Render the individual game results
                allGamesResultsContainer.innerHTML = '';

                if (games.length === 0) {
                allGamesResultsContainer.innerHTML = '<p class="text-center">No hay partidos.</p>';
                    return;
                }

                // Sort games by KickOffTime (descending - most recent first)
                const sortedGames = [...games].sort((a, b) => {
                    const dateA = a.KickOffTime && a.KickOffTime.toDate ? a.KickOffTime.toDate() : new Date(a.KickOffTime);
                    const dateB = b.KickOffTime && b.KickOffTime.toDate ? b.KickOffTime.toDate() : new Date(b.KickOffTime);
                    return dateB - dateA;
                });

                // Render each game with its predictions
                for (const game of sortedGames) {
                    const gameCard = document.createElement('div');
                    gameCard.classList.add('game-results-card', 'app-card');

                    // Get predictions for this game
                    const gamePredictions = predictions.filter(p => p.gameId === game.id);

                    const statusValue = (game.Status || game.status || 'upcoming').toLowerCase();
                    const statusLabel = statusLabelMap[statusValue] || statusValue;
                    const statusClass = statusClassMap[statusValue] || 'upcoming';
                    const hasFinalScore = game.HomeScore !== null && game.AwayScore !== null;
                    const actualResultDisplay = (statusValue === 'finished' || statusValue === 'live' || statusValue === 'in_play') && hasFinalScore
                        ? `<p class="actual-result">Resultado real: ${game.HomeScore} - ${game.AwayScore}</p>`
                        : `<p class="actual-result">Resultado real: Aún no disponible</p>`;

                    const predictionsHTML = (statusValue === 'finished' || statusValue === 'live' || statusValue === 'in_play')
                        ? gamePredictions.length > 0
                            ? gamePredictions.map(prediction => {
                                const points = calculatePoints(prediction, game);
                                let pointsDisplay = '';
                                let pointsClass = 'text-muted';
                                const predictedHome = prediction.predictedHomeScore ?? '-';
                                const predictedAway = prediction.predictedAwayScore ?? '-';

                                if (points === null) {
                                    pointsDisplay = 'N/A';
                                    pointsClass = 'pending';
                                } else if (points === 10) {
                                    pointsDisplay = `(${points} puntos - perfecto)`;
                                    pointsClass = 'text-success';
                                } else if (points >= 5) {
                                    pointsDisplay = `(${points} puntos)`;
                                    pointsClass = 'text-info';
                                } else if (points > 0) {
                                    pointsDisplay = `(${points} puntos)`;
                                    pointsClass = 'text-warning';
                                } else {
                                    pointsDisplay = `(${points} puntos)`;
                                    pointsClass = 'text-danger';
                                }

                                return `
                                    <div class="prediction-entry">
                                        <span><strong>${prediction.playerName || 'Anónimo'}</strong> predijo: ${predictedHome} - ${predictedAway}</span>
                                        <span class="score ${pointsClass}">${pointsDisplay}</span>
                                    </div>
                                `;
                            }).join('')
                            : '<p class="text-muted">Todavía no hay predicciones para este partido.</p>'
                        : '<p class="text-muted">Las predicciones se muestran cuando finaliza el partido.</p>';

                    const phaseLabel = resolveStageLabel(game);
                    const kickoffDate = game.KickOffTime ? new Date(game.KickOffTime) : null;
                    const kickoffLabel = kickoffDate && !Number.isNaN(kickoffDate.getTime())
                        ? kickoffDate.toLocaleString([], { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: 'numeric' })
                        : 'Fecha por confirmar';

                    gameCard.innerHTML = `
                        <h3 class="game-header">
                            ${game.HomeTeam} vs ${game.AwayTeam}
                            <span class="game-status ${statusClass}">${statusLabel}</span>
                        </h3>
                        <p class="game-info">${phaseLabel} - ${kickoffLabel}</p>
                        ${actualResultDisplay}
                        <hr>
                        <h4 class="mb-3">Predicciones:</h4>
                        <div class="predictions-list">
                            ${predictionsHTML}
                        </div>
                    `;
                    allGamesResultsContainer.appendChild(gameCard);
                }

            } catch (error) {
                console.error("Error loading all results: ", error);
                allGamesResultsContainer.innerHTML = '<p class="text-center" style="color: red;">Error al cargar resultados. Intenta nuevamente más tarde.</p>';
            }
        }

        // --- Render Overall Leaderboard ---
        function renderLeaderboardContainer(playerStats, userNames) {
            leaderboardList.innerHTML = '';
            overallLeaderboardContainer.style.display = 'block';

            // Convert playerStats array to entries and sort by stats
            const sortedPlayers = Object.entries(playerStats).sort(([idA, statsA], [idB, statsB]) => {
                if (statsB.totalPoints !== statsA.totalPoints) {
                    return statsB.totalPoints - statsA.totalPoints;
                }
                if (statsB.fechasWonCount !== statsA.fechasWonCount) {
                    return statsB.fechasWonCount - statsA.fechasWonCount;
                }
                if (statsB.perfectScoresCount !== statsA.perfectScoresCount) {
                    return statsB.perfectScoresCount - statsA.perfectScoresCount;
                }
                return (userNames[idA] || '').localeCompare(userNames[idB] || '');
            });

            if (sortedPlayers.length === 0) {
                leaderboardList.innerHTML = '<p class="text-center text-muted">No total scores to display yet.</p>';
                return;
            }

            // Use ui-helpers to render the table with click handler callback
            const table = renderLeaderboardTable(sortedPlayers, userNames, (userId) => {
                openPlayerHistory(userId, db, userDisplayNamesGlobal);
            });
            leaderboardList.appendChild(table);
        }

        // Call the function when the page loads
        document.addEventListener('DOMContentLoaded', loadAllResults);

        async function loadSyncStatus() {
            const banner = document.getElementById('sync-status-banner');
            if (!banner) return;

            try {
                const statusRef = doc(db, 'sync_status', TOURNAMENT_CONFIG.tournamentId);
                const statusSnap = await getDoc(statusRef);
                const data = statusSnap.exists() ? statusSnap.data() : {};
                const lastSync = data.lastSuccessAt || data.lastSyncedAt || data.lastRunAt;
                const lastText = lastSync
                    ? (lastSync.toDate ? lastSync.toDate().toLocaleString() : new Date(lastSync).toLocaleString())
                    : 'N/A';
                banner.textContent = `Actualización automática post-partido (no en vivo). Última sync: ${lastText}`;
            } catch (error) {
                banner.textContent = 'Actualización automática post-partido (no en vivo).';
            }
        }
    </script>
</body>
</html>
